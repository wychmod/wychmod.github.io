## 1.1 学习JVM的动力

>1.Java虚拟机是Java平台的基石，其负责其硬件和操作系统的独立性，其编译的代码很小以及保护用户免受恶意程序攻击的能力。
>2.Java虚拟机是一种抽象计算机，像真正的计算机一样，它有一个指令集并在运行时操作各种内存区域。
>3.Java虚拟机不承担任何特定的实现技术、主机硬件或主机操作系统，它本身并没有被解释。
>4.Java虚拟机不知道Java编程语言，只知道特定的二进制格式，即 class 文件格式， class 文件包含Java虚拟机指令（或字节码）和符号表，以及其他辅助信息。
>5.出于安全考虑，Java虚拟机对 class 文件中的代码施加了强大的语法和结构约束，但是，任何具有可以用有效 class 文件表示的功能的语言都可以由Java虚拟机托管，由通用的、与机器无关的平台吸引，其他语言的实现者可以将Java虚拟机作为其语言的交付工具。


## 1.2 计算机体系结构

> 遵循冯诺依曼计算机结构

![](../youdaonote-images/Pasted%20image%2020230807144809.png)

## 1.3  机器语言

我们把CPU能够直接认识的数据指令，称为机器语言，也就是010101001这种形式

## 1.4 汇编语言

低级语言，通过汇编器翻译成机器语言
MOV、PUSH、ADD等
> 对机器友好，执行效率比较高，移植性差
> 但是人类操作起来还是不太方便，或者需要专业的人员

## 1.5编译型和解释型

### 1.5.1 编译型

> 使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成
> 可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式

C、C++、GoLang

```
编译型语言：
执行速度快、效率高；依靠编译器、跨平台性差些。
把做好的源程序全部编译成二进制代码的可运行程序。然后，可直接运行这个程序。
```

### 1.5.2 解释型

>使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。
>是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。

Python、Javascript

```
解释型语言：
执行速度慢、效率低；依靠解释器、跨平台性好。
把做好的源程序翻译一句，然后执行一句，直至结束。
```

### 1.5.3 Java属于哪种？

Java属于编译型+解释型的高级语言

```
其实并不是因为有javac将Java源码编译成class文件，才说Java属于编译+解释语言，因为在这个编译器编译之后，生成的类文件不能直接在对应的平台上运行。 那为何又说Java是编译+解释语言呢？因为class文件最终是通过JVM来翻译才能在对应的平台上运行，而这 个翻译大多数时候是解释的过程，但是也会有编译，称之为运行时编译，即JIT(Just In Time)。 综上所述，Java是一门编译型+解释型的高级语言。
```

## 1.6 JVM是什么

Java Virtual Machine(Java虚拟机)

![](../youdaonote-images/Pasted%20image%2020230807150844.png)

![](../youdaonote-images/Pasted%20image%2020230807150952.png)

## 2 JVM 到底该学习什么

![](../youdaonote-images/Pasted%20image%2020230807170824.png)
1. 源码到类文件
2. 类文件到JVM
3. JVM各种知识【内部结构、执行方式、垃圾回收、本地调用等】

## 2.1 源码到类文件

**源码demo**

```java
class Person{

private String name="Jack";

private int age;

private final double salary=100;

private static String address;

private final static String hobby="Programming";

private static Object obj=new Object();

public void say(){

System.out.println("person say...");

}

public static int calc(int op1,int op2){

op1=3;

int result=op1+op2;

Object obj=new Object();

return result;

}

public static void main(String[] args){

calc(1,2);

}

}
```

> 编译: javac -g:vars Person.java ---> Person.class

## 2.2 编译器干了什么

![](../youdaonote-images/Pasted%20image%2020230807171222.png)

> 由上可知，其实我们的编译器其实做的事情其实就是“对等信息转换”。JAVA文件中的信息其实跟我们Class文件中的信息，其实是一样的。

## 2.3 类文件（class 文件）

### 2.3.1 16进制class文件
```java
cafe babe 0000 0034 003f 0a00 0a00 2b08 002c 0900 0d00 2d06 4059 0000 0000 0000 0900 0d00 2e09 002f 0030 0800 310a 0032 0033 0700 340a 000d 0035 0900 0d00 3607 0037 0100 046e 616d 6501 0012 4c6a 6176 612f 6c61 6e67 2f53 7472 696e 673b 0100 0361 6765 0100 0149 0100 0673 616c 6172 7901 0001 4401 000d 436f 6e73 7461 6e74 ......
```

### 2.3.2 The ClassFile Structure

```java
ClassFile {

u4 magic;

u2 minor_version;

u2 major_version;

u2 constant_pool_count;

cp_info constant_pool[constant_pool_count-1];

u2 access_flags;

u2 this_class;

u2 super_class;

u2 interfaces_count;

u2 interfaces[interfaces_count];

u2 fields_count;

field_info fields[fields_count];

u2 methods_count;

method_info methods[methods_count];

u2 attributes_count;

attribute_info attributes[attributes_count];

}
```

### 2.3.3 分析classfile结构

- u4: cafebabe 
	magic: magic项提供标识类文件格式的magic数字
- u2+u2:0000+0034，34等于10进制的52，表示JDK8
	minor_version
	major_version
- u2:003f=63(10进制)
	constant_pool_count: constant_pool_count项的值等于constant_pool表的表项数加1。
	表示常量池中的数量是62
- cp_info constant_pool[constant_pool_count-1]
	常量池主要存储两方面内容：字面量(Literal)和符号引用(Symbolic References)

> 字面量:文本字符串，final修饰等 
> 符号引用：类和接口的全限定名、字段名称和描述符、方法名称和描述符

### 2.3.4 反编译验证

JVM相对class文件来说可以理解为是操作系统；class文件相对JVM来说可以理解为是汇编语言或者机器语言。

> 编译指令：javap -v -p Person.class

![](../youdaonote-images/Pasted%20image%2020230807172352.png)

![](../youdaonote-images/Pasted%20image%2020230807172427.png)

![](../youdaonote-images/Pasted%20image%2020230807172441.png)

## 3 类加载机制

类加载机制是指我们将类的字节码文件所包含的数据读入内存，同时我们会生成数据的访问入口的一种
特殊机制。那么我们可以得知，类加载的最终产品是数据访问入口。

![](../youdaonote-images/Pasted%20image%2020230807172801.png)


字节码文件可以用什么方式进行加载呢？

**加载.class文件的方式**

- 从本地系统中直接加载
	- 典型场景：这个我就不废话了

- 通过网络下载.class文件
	- 典型场景：Web Applet，也就是我们的小程序应用
- 从zip，jar等归档文件中加载.class文件
	- 典型场景：后续演变为jar、war格式
- 从专有数据库中提取.class文件
	- 典型场景：JSP应用从专有数据库中提取.class文件，较为少见
- 将Java源文件动态编译为.class文件，也就是运行时计算而成
	- 典型场景：动态代理技术
- 从加密文件中获取，
	- 典型场景：典型的防Class文件被反编译的保护措施

![](../youdaonote-images/Pasted%20image%2020230807173041.png)

### 3.1 装载（Load）
> 查找和导入class文件

1. 通过一个类的全限定名获取定义此类的二进制字节流（由上可知，我们不一定从字节码文件中获得，还有上述很多种方式）

思考：那么这个时候我们是不是需要一个工具，寻找器，来寻找获取我们的二进制字节流?

java中恰好有这么一段代码模块。可以实现通过类全名来获取此类的二进制字节流这个动作，并且将这个动作放到放到java虚拟机外部去实现，以便让应用程序决定如何获取所需要的类，实现这个动作的代码模块成为“类加载器”。

2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口

> 获取类的二进制字节流的阶段是我们JAVA程序员最关注的阶段，也是操控性最强的一个阶段。因为这个阶段我 们可以对于我们的类加载器进行操作，比如我们想自定义类加载器进行操作用以完成加载，又或者我们想通过 JAVA Agent来完成我们的字节码增强操作。

在我们的装载阶段完成之后，这个时候在我们的内存当中，我们的运行时数据区的方法区以及堆就已经有数据了。
- **方法区**：类信息，静态变量，常量
- **堆**：代表被加载类的java.lang.Class对象

即时编译之后的热点代码并不在这个阶段进入方法区

### 3.2 链接（LINK）

#### 3.2.1 验证(Verify)

>验证只要是为了确保Class文件中的字节流包含的信息完全符合当前虚拟机的要求，并且还要求我们的信息不会危害虚拟机自身的安全，导致虚拟机的崩溃。
>