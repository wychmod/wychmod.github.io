## 1.1 学习JVM的动力

>1.Java虚拟机是Java平台的基石，其负责其硬件和操作系统的独立性，其编译的代码很小以及保护用户免受恶意程序攻击的能力。
>2.Java虚拟机是一种抽象计算机，像真正的计算机一样，它有一个指令集并在运行时操作各种内存区域。
>3.Java虚拟机不承担任何特定的实现技术、主机硬件或主机操作系统，它本身并没有被解释。
>4.Java虚拟机不知道Java编程语言，只知道特定的二进制格式，即 class 文件格式， class 文件包含Java虚拟机指令（或字节码）和符号表，以及其他辅助信息。
>5.出于安全考虑，Java虚拟机对 class 文件中的代码施加了强大的语法和结构约束，但是，任何具有可以用有效 class 文件表示的功能的语言都可以由Java虚拟机托管，由通用的、与机器无关的平台吸引，其他语言的实现者可以将Java虚拟机作为其语言的交付工具。


## 1.2 计算机体系结构

> 遵循冯诺依曼计算机结构

![](../youdaonote-images/Pasted%20image%2020230807144809.png)

## 1.3  机器语言

我们把CPU能够直接认识的数据指令，称为机器语言，也就是010101001这种形式

## 1.4 汇编语言

低级语言，通过汇编器翻译成机器语言
MOV、PUSH、ADD等
> 对机器友好，执行效率比较高，移植性差
> 但是人类操作起来还是不太方便，或者需要专业的人员

## 1.5编译型和解释型

### 1.5.1 编译型

> 使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成
> 可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式

C、C++、GoLang

```
编译型语言：
执行速度快、效率高；依靠编译器、跨平台性差些。
把做好的源程序全部编译成二进制代码的可运行程序。然后，可直接运行这个程序。
```

### 1.5.2 解释型

>使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。
>是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。

Python、Javascript

```
解释型语言：
执行速度慢、效率低；依靠解释器、跨平台性好。
把做好的源程序翻译一句，然后执行一句，直至结束。
```

### 1.5.3 Java属于哪种？

Java属于编译型+解释型的高级语言

```
其实并不是因为有javac将Java源码编译成class文件，才说Java属于编译+解释语言，因为在这个编译器编译之后，生成的类文件不能直接在对应的平台上运行。 那为何又说Java是编译+解释语言呢？因为class文件最终是通过JVM来翻译才能在对应的平台上运行，而这 个翻译大多数时候是解释的过程，但是也会有编译，称之为运行时编译，即JIT(Just In Time)。 综上所述，Java是一门编译型+解释型的高级语言。
```

## 1.6 JVM是什么

Java Virtual Machine(Java虚拟机)

![](../youdaonote-images/Pasted%20image%2020230807150844.png)

![](../youdaonote-images/Pasted%20image%2020230807150952.png)

## 2 JVM 到底该学习什么

![](../youdaonote-images/Pasted%20image%2020230807170824.png)
1. 源码到类文件
2. 类文件到JVM
3. JVM各种知识【内部结构、执行方式、垃圾回收、本地调用等】

## 2.1 源码到类文件

**源码demo**

```java
class Person{

private String name="Jack";

private int age;

private final double salary=100;

private static String address;

private final static String hobby="Programming";

private static Object obj=new Object();

public void say(){

System.out.println("person say...");

}

public static int calc(int op1,int op2){

op1=3;

int result=op1+op2;

Object obj=new Object();

return result;

}

public static void main(String[] args){

calc(1,2);

}

}
```

> 编译: javac -g:vars Person.java ---> Person.class

## 2.2 编译器干了什么

![](../youdaonote-images/Pasted%20image%2020230807171222.png)

> 由上可知，其实我们的编译器其实做的事情其实就是“对等信息转换”。JAVA文件中的信息其实跟我们Class文件中的信息，其实是一样的。

## 2.3 类文件（class 文件）

### 2.3.1 16进制class文件
```java
cafe babe 0000 0034 003f 0a00 0a00 2b08 002c 0900 0d00 2d06 4059 0000 0000 0000 0900 0d00 2e09 002f 0030 0800 310a 0032 0033 0700 340a 000d 0035 0900 0d00 3607 0037 0100 046e 616d 6501 0012 4c6a 6176 612f 6c61 6e67 2f53 7472 696e 673b 0100 0361 6765 0100 0149 0100 0673 616c 6172 7901 0001 4401 000d 436f 6e73 7461 6e74 ......
```

### 2.3.2 The ClassFile Structure

```java
ClassFile {

u4 magic;

u2 minor_version;

u2 major_version;

u2 constant_pool_count;

cp_info constant_pool[constant_pool_count-1];

u2 access_flags;

u2 this_class;

u2 super_class;

u2 interfaces_count;

u2 interfaces[interfaces_count];

u2 fields_count;

field_info fields[fields_count];

u2 methods_count;

method_info methods[methods_count];

u2 attributes_count;

attribute_info attributes[attributes_count];

}
```

### 2.3.3 