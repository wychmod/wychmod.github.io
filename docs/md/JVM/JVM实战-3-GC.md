# 1. GC的基础知识

## 1.1 什么是垃圾

> C语言申请内存：malloc free
>
> C++： new delete
>
> c/C++ 手动回收内存
>
> Java: new ？
>
> 自动内存回收，编程上简单，系统不容易出错，手动释放内存，容易出两种类型的问题：
>
> 1. 忘记回收
> 2. 多次回收

没有任何引用指向的一个对象或者多个对象（循环引用）

## 1.2 如何定位垃圾

### 1.2.1 引用计数（ReferenceCount）

### 1.2.2 根可达算法(RootSearching)

> 根可达算法（Root Reachable Algorithm）是一种用于图中节点可达性判断的算法。该算法通过判断从根节点出发，是否可以到达目标节点来确定节点的可达性。

![](../youdaonote-images/Pasted%20image%2020230813232206.png)

## 1.3 常见的垃圾回收算法

### 1.3.1 标记清除(mark sweep)
- 标记
找出内存中需要回收的对象，并且把它们标记出来(需要扫描两遍，第一遍找出不可回收的，第二遍找到可以回收的)
![](../youdaonote-images/Pasted%20image%2020230813232659.png)
- 清除
清除掉被标记需要回收的对象，释放出对应的内存空间
![](../youdaonote-images/Pasted%20image%2020230813232710.png)
- 缺点
位置不连续 产生碎片 效率偏低（两遍扫描）

> 适合存活对象较多的情况
### 1.3.2 拷贝算法 (copying)
![](../youdaonote-images/Pasted%20image%2020230813233110.png)

> 没有碎片，浪费空间，移动对象，需要调整对象引用，适合活跃对象较少的情况。
### 1.3.3 标记压缩(mark compact)

标记过程仍然与"标记-清除"算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

> 其实上述过程相对"复制算法"来讲，少了一个"保留区"

![](../youdaonote-images/Pasted%20image%2020230813233441.png)

让所有存活的对象都向一端移动，清理掉边界意外的内存。

![](../youdaonote-images/Pasted%20image%2020230813233453.png)