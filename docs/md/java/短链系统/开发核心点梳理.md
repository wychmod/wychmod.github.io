
# 1. 异步请求解决方案

> @Async+ThreadPoolTaskExecutor⾃定义线程池

- 使⽤场景
	- 适⽤于处理log、发送邮件、短信……等
	- 涉及到⽹络IO调⽤等操作
- 使⽤⽅式
	- 启动类⾥⾯使⽤@EnableAsync注解开启功能，⾃动扫描
	- 定义异步任务类并使⽤@Component标记组件被容器扫描,异步⽅法加上@Async
- 注意点
	- 在Async ⽅法上标注@Transactional是没⽤的，但在Async⽅法调⽤的⽅法上标注@Transactional 是有效的
	- 不能在同一个类，底层是代理类实现的，同一个类中没法代理，直接调用

线程池配置类：
```java
@Configuration  
@EnableAsync  
public class ThreadPoolTaskConfig {  
  
    @Bean("threadPoolTaskExecutor")  
    public ThreadPoolTaskExecutor threadPoolTaskExecutor(){  
  
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();  
  
        //线程池创建的核心线程数，线程池维护线程的最少数量，即使没有任务需要执行，也会一直存活  
        //如果设置allowCoreThreadTimeout=true（默认false）时，核心线程会超时关闭  
        executor.setCorePoolSize(4);  
        //executor.setAllowCoreThreadTimeOut();  
  
        //阻塞队列 当核心线程数达到最大时，新任务会放在队列中排队等待执行  
        executor.setQueueCapacity(10000);  
  
        //最大线程池数量，当线程数>=corePoolSize，且任务队列已满时。线程池会创建新线程来处理任务  
        //任务队列已满时, 且当线程数=maxPoolSize，，线程池会拒绝处理任务而抛出异常  
        executor.setMaxPoolSize(8);  
  
        //当线程空闲时间达到keepAliveTime时，线程会退出，直到线程数量=corePoolSize  
        //允许线程空闲时间30秒，当maxPoolSize的线程在空闲时间到达的时候销毁  
        //如果allowCoreThreadTimeout=true，则会直到线程数量=0  
        executor.setKeepAliveSeconds(30);  
  
        //spring 提供的 ThreadPoolTaskExecutor 线程池，是有setThreadNamePrefix() 方法的。  
        //jdk 提供的ThreadPoolExecutor 线程池是没有 setThreadNamePrefix() 方法的  
        executor.setThreadNamePrefix("自定义线程池-");  
  
        // rejection-policy：当pool已经达到max size的时候，如何处理新任务  
        // CallerRunsPolicy()：交由调用方线程运行，比如 main 线程；如果添加到线程池失败，那么主线程会自己去执行该任务，不会等待线程池中的线程去执行  
        // AbortPolicy()：该策略是线程池的默认策略，如果线程池队列满了丢掉这个任务并且抛出RejectedExecutionException异常。  
        // DiscardPolicy()：如果线程池队列满了，会直接丢掉这个任务并且不会有任何异常  
        // DiscardOldestPolicy()：丢弃队列中最老的任务，队列满了，会将最早进入队列的任务删掉腾出空间，再尝试加入队列  
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.AbortPolicy());  
  
        executor.initialize();  
        return executor;  
    }  
}
```

- ⾼并发下核⼼线程怎么设置？
	- 分IO密集还是CPU密集
		- CPU密集设置为跟核⼼数⼀样⼤⼩
		- IO密集型设置为2倍CPU核⼼数


> 采⽤异步发送⽤户体验变好了，但是存在丢失的可能，阻塞队列存储内存中，如果队列⻓度过多则重启容易出现丢失数据情况，会出现oom的情况


# 2. 短链方案

## 重定向码的选择
选用302临时重定向，能统计数据和拉黑
选用301就会永远直接跳过去。

# 哈希生成短链

MurmurHash 是一种非加密的高效哈希算法，由 Austin Appleby 于 2008 年开发。它因其高性能、均匀分布和较低的碰撞率，成为了很多高效数据处理场景的首选，广泛应用于 Redis、MemCache、Cassandra 等知名软件中。以下是其详细介绍：

  

- **高性能**：MurmurHash 的计算速度非常快，特别适合大规模数据处理的场景。其高效性得益于简单的位运算和乘法操作，相比 MD5、SHA 等加密哈希函数，性能可高出十倍以上。
- **非加密性**：MurmurHash 不是为加密设计的，不能保证数据的安全性，但它的目标是快速生成散列值，无需复杂的安全计算，适用于一般的哈希检索操作。
- **良好的分布性**：该算法生成的散列值分布均匀，碰撞率低，这对于需要分散存储数据的场景非常关键，比如哈希表或分布式存储系统。
- **版本特性**：MurmurHash3 是当前的主流版本，改进了前两个版本中的一些弱点，适用于 64 位和 128 位的需求，并提供更强的哈希质量。

  

MurmurHash 适合用于生成短链，主要原因如下：

  

- **计算速度快**：短链生成需要处理大量的长链接数据，MurmurHash 的高性能能够快速将长链接转换为哈希值，满足实时性要求，不会因计算耗时过长影响短链生成效率。
- **哈希值分布均匀**：生成短链时，希望不同长链接生成的短链尽量不重复，MurmurHash 生成的散列值分布均匀，碰撞率低，可有效减少短链冲突的情况，保证每个长链接都能尽可能对应唯一的短链。
- **非加密特性合适**：短链生成不需要对数据进行加密，MurmurHash 的非加密特性使其无需执行复杂的安全计算，能在保证功能的同时降低计算开销。
- **便于转换为短链格式**：MurmurHash 可生成 32 位或 128 位的哈希值，通常选择 32 位哈希值，其能表示的最大值近 43 亿，对于中小型公司业务而言基本够用。并且可以将其转换为 62 进制（a - z、A - Z、0 - 9）字符串，进一步缩短长度，方便与固定短链域名拼接形成短链。

拼上库表位就更多了。