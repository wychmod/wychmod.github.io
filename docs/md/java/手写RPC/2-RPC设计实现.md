# 1. 核心注解的设计

## 1.1 服务提供者注解设计的逻辑

一个极简的服务提供者注册到注册中心的元数据应该包含如下几部分：服务名称、服务版本号、服务地址、服务端口号、服务分组信息。

1. 服务名称：服务的名称往往是提供服务的接口的完整类名。
2. 服务版本号：标识当前服务的版本号，以版本号的形式来区分不同版本所提供的不同服务。
3. 服务地址：服务提供者发布的服务所在的网络地址，往往是一个IP地址或者域名。
4. 服务端口号：服务提供者发布的服务所监听的端口号。
5. 服务分组：对不同的服务进行分组，达到服务隔离的效果。

其实对于一个应用程序来说，启动后一个应用程序监听一个IP地址/域名和端口就足够了，而不需要为同一个应用程序中的每一个RPC服务都单独去监听一个IP地址/域名和端口，我们只需要为服务提供者所在的项目工程统一配置服务监听的IP地址/域名和端口号即可。又因为对于一个较完备的RPC框架来说，需要支持多种不同的注册中心，同时，针对同一个服务提供者来说，往往会将其服务统一注册到同一种类型的注册中心上，所以，注册中心的地址和类型以及负载均衡类型也都可以在项目工程中统一配置。

在我们设计的服务提供者的注解中，可以不包含服务地址和服务端口号。

**所以，在我们设计的服务提供者注解中就只剩下了服务名称、服务版本号和服务分组三个核心属性，并且这三个核心属性可以确定一个唯一的服务提供者。**


## 1.2 服务消费者注解设计的逻辑

一个极简的服务消费者注解需要包含如下几个部分：

1. 注册中心地址：服务消费者需要从注册中心中订阅服务提供者的信息。
2. 注册中心的类型：由于RPC框架需要支持不同类型的注册中心，所以在服务消费者中需要配置服务的注册中心类型。
3. 负载均衡类型：当具备多个服务提供者时，服务消费者需要实现负载均衡，在多个服务提供者中选择一个有效的服务提供者进行调用。
4. 版本号：与服务提供者对应，只有服务名称、服务版本号、服务分组与服务提供者都匹配时，才能调用到服务提供者相应的服务。
5. 服务分组：与服务提供者对应，只有服务名称、服务版本号、服务分组与服务提供者都匹配时，才能调用到服务提供者相应的服务。
6. 序列化类型：服务消费者调用服务提供者的服务时，数据需要在网络中进行传输，这就涉及到数据的序列化方式。
7. 超时时间：服务消费者调用服务提供者的服务时，为避免一直阻塞，造成服务性能低下的问题，这里根据实际情况可以设置超时时间。
8. 是否异步调用：一个较为完备的RPC框架，需要在服务消费者一侧实现同步和异步调用。
9. 是否单向调用：一个较为完备的RPC框架，需要在服务消费者一侧实现是否是单向调用。
10. 代理方式：在服务消费者一侧需要实现根据不同的代理方式来对远程的服务提供者发起调用。

**服务消费者需要调用的服务提供者发布的服务名称，是从注册中心中获取的，所以，在服务消费者中不用配置服务名称。**

**在实现RPC框架的服务消费者时，这里不仅支持在项目工程中统一配置注册中心地址、注册中心类型和负载均衡类型，还支持在注解中针对具体的服务不同，配置不同的注册中心地址、注册中心类型和负载均衡类型。**

