# 1. 索引是什么
## 1.1 索引是什么
数据库索引，是数据库管理系统(DBMS) 中一个排序的数据结构，以协助快速查询、更新数据库表中数据。

### 1.1.1 索引类型

在InnoDB里面，索引类型有三种，普通索引、唯 一索引(主键索引是特殊的唯—索引) 、全文索引。

全文(Ful text):针对比较大的数据，比如我们存放的是消息内容、一篇文章，有几KB的数据的这种情况，如果要解决like 查询在全文匹配的时候效率低的问题，可以创建全文索引。只有文本类型的字段才可以创建全文索引，比如char、varchar、text。

```sql
CREATE TABLE 'fulltext test (
"content' varchar(50) DEFAULT NULL, FULLTEXT KEY content' (content')
);

# 语法:
select *from fulltext test where match(content) against('三体'INNATURALLANGUAGEMODE);
```

# 2. 索引存储模型推演
## 2.1 二分查找

可以考虑用有序数组作为索引的数据结构。有序数组的等值查询和比较查询效率非常高，但是更新数据的时候会出现 一个问题，可能要挪动大量的数据 (改变index)，所以只适合存储静态的数据。

为了支持频繁的修改，比如插入数据，我们需要采用链表。链表的话，如果是单链表，它的查找效率还是不够高。

## 2.2 二叉查找树(BSTBinarySearch Tree)

**高效查找的链表**

在子树所有的节点都小于父节点，右子树所有的节点都大于父节点。投脱到平圃以后，就是一个有序的线性表。二叉查找树既能够实现快速查找，又能够实现快速插入。

最坏情况是查找效率变成On，变成斜树。

![](../youdaonote-images/Pasted%20image%2020230706213610.png)



## 2.3 平衡二叉树 (AVL Tree)(左旋、右旋)

平衡二叉树的定义:左右子树;深度差绝对值不能超过1。通过左旋右旋保持平衡。

![](../youdaonote-images/Pasted%20image%2020230706214148.png)

### 2.3.1 AVL树用于存储索引数据
**可能会出现如下问题**：
当我们用树的结构来存储索引的时候，访问一个节点就要跟磁盘之间发生一次IO操作。InnoDB操作磁盘的最小的单位是一页（或者叫一个磁盘块），大小是16K。一个树的节点必须设计成16K的大小，不然就会出现读不够的情况。

如果只是键值+数据+引用是非常小的，如果一个单元只存一个信息，就需要很多次IO操作。

**为了解决这个问题**：

1. 让每个节点存储更多的数据
2. 节点上的关键字的数量越多，我们的指针数也越多，也就是意味着可以有更多的分叉。
分叉越多，树的深度越少，io次数越少。

## 2.4 多路平衡査找村(BTree)(分裂、合井)

跟AVL树一样，B树在枝节点和叶子节点存储键值、数据地址、节点引用。

特点:分叉数 (路数)永远比关键字数多1。

节点的分裂和合并，其实就是lnnoDB页的分裂和合并。所以不在频繁更新的列上建立索引。

如果索引键值有序，写满一页接着开辟一个新的页。如果索引键值无序，存储过程造成大量磁盘碎片，带来频繁的page 分裂和合并。

![](../youdaonote-images/Pasted%20image%2020230706222807.png)

![](../youdaonote-images/Pasted%20image%2020230706222925.png)

![](../youdaonote-images/Pasted%20image%2020230706222940.png)

![](../youdaonote-images/Pasted%20image%2020230706222949.png)



## 2.5 B+树(加强版多路平衡查找树)

![image\_1cacafpso19vpkik1j5rtrd17cm3a.png-158.1kB](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/4/9/16a01bd2a6c7a65f\~tplv-t2oaga2asx-zoom-in-crop-mark:3024:0:0:0.awebp "image_1cacafpso19vpkik1j5rtrd17cm3a.png-158.1kB")

特点：

1. 它的关键字的数量是跟路数相等的；
2. B+Tree的根节点和枝节点中都不会存储数据，只有叶子节点才存储数据。
3. B+Tee的每个叶子节点增加了一个指向相邻叶子节点的指针，它的最后一个
数据会指向下一个叶子节点的第一个数据，形成了一个有序链表的结构。

优势：

1. B Tree的变种:每个节点存储更多关键字；路数更多
2. 扫库、扫表能力更强（如果我们要对表进行全表扫描，只需要遍历叶子节点就可以了，不需要遍历整棵B+Tree拿到所有的数据)
3. B+Tree的磁盘读写能力相对于B Tree来说更强（根节点和枝节点不保存数据区，所以一个节点可以保存更多的关键字，一次磁盘加载的关键字更多)
4. 排序能力更强（因为叶子节点上有下一个数据区的指针，数据形成了链表)
5. 效率更加稳定(B+Tee永远是在叶子节点拿到数据，所以IO次数是稳定的)

## 2.6 为什么不用红黑树

1、只有两路; 2、不够平衡。
红黑树一般只放在内存里面用。例如Java的Tree/Map,它可以用来实现一致性哈希。

## 2.7 Hash索引

在InnoDB中，不能显式地创建一个哈希索引 (所谓的支持哈希索引指的是AHl，自适应哈希，它是InnoDB自动为buffer pool 中的热点页创建的索引) 。

memory 存储引擎可以使用Hash 索引。

# 3. B+Tree 落地形式
## 3.1 MySQL数据存储文件

MySQL 的数据都是文件的形式存放在磁盘中的，在MySQL中有这么一个参数:
```sql
show VARIABLES LIKE 'datadir';
```

每张InnoDB的表有两个文件(.frm和.ibd),MylSAM的表有三个文件(.frm、.MYD、.MYI) 
.frm是MySQL里面表结构定义的文件，不管你建表的时候选用任何一个存储引擎都会生成

### 3.1.1 MyISAM

一个是.MYD文件，D代表Data,是MyISAM的数据文件，存放数据记录，比如我
们的user_myisam表的所有的表数据。
一个是.MYI文件，I代表Index,是MyISAM的索引文件，存放索引，比如我们在id字段上面创建了一个主键索引，那么主键索引就是在这个索引文件里面。一个索引就会有一棵B+Tree,所有的B+Tree都在这个myi文件里面。

MyISAM 的B+Tree 里面，叶子节点存储的是数据文件对应的磁盘地址。所以从索 引文件. MY1 中找到键值后，会到数据文件. MYD 中获取相应的数据记录。

![](../youdaonote-images/Pasted%20image%2020230706230147.png)

> MyISAM非主键索引跟主键索引存储和检索数据的方式是没有任何区别的

### 3.1.2 InnoDB

在lnnoDB的某个索引的叶子节点上，它直接存储了我们的数据。
**所以，在InnoDB中索引即数据，数据即索引，就是这个原因。**

聚簇索引:就是索引键值的逻辑顺序跟表数据行的物理存储顺序是一致的。

InnoDB组织数据的方式就是（聚集）索引组织表(clustered index organize table)。如果说一张表创建了主键索引，那么这个主键索引就是聚集索引，决定数据行的物理存储顺序。

二级索引储存的不是地址，因为地址会变，储存的是主键的值。二级索引会回表。

**没有主键：**

1. 如果我们定义了主键(PRIMARY KEY),那么InnoDB会选择主键作为聚集索引.
2. 如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引。
3. 如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐藏的聚集索引，它会随着行记录的写入而主键递增。

# 4. 索引使用原则

## 4.1 列的离散度

第一个叫做列的离散度，我们先来看一下列的离散度的公式：
count(distinct(column_name):count(\*),列的全部不同值和所有数据行的比例。数据行数相同的情况下，分子越大，列的离散度就越高。 性别的离散度就非常低。如果列的重复值越多，离散度就越低，重复值越少，离散度就越高