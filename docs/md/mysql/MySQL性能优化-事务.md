
# 1.什么是数据库的事务

```sql
select version();
show variables like '%engine%';
show global variables like "tx_isolation";
```

## 1.1 事务的定义

事务是数据库管理系统(DBMS) 执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。

1. 所谓的逻辑单位，意味着它是数据库最小的工作单元，是不可以再分的。
2. 它可能包含了一个或者一系列的DML语句，包括 insert delete update.

## 1.2 哪些存储引擎支持事务

除了做集群的NDB 之外，只有Inn oDB支持事务，这个也是它成为默认的存储引擎
的 一个重要原因。

## 1.3 事务的四大特性

- 原子性: 要么都成功要么都失败
	实现： 通过undo log 来实现的，它记录了数据修改之前的值(逻 辑日志)，一旦发生异常，就可以用undo 10g 来实现回滚操作。
- 隔离性：很多个的事务，对表或者行的并发操作，应该是透明的，互相不干扰的。
	实现：
	1. 对于普通的select使用快照(snapshot read),底层使用Multi version currency control(mvcc)来实现.
	2. 加锁的select,底层使用记录锁，或者间隙锁，临键锁。
- 持久性: 
	实现：redolog和doublewritebuffer (双写缓冲)来实现的，先写到内存的buffer pool 里面，同时记录redo log，如果在刷盘之前 出现要特，在理高后說阿以续现redo1oo12各，一入到裝理，(保近数据的父性。
- 一致性： 数据库的完整性约束没有被破坏 ，事务执行的前后都是合法的数据状态。

## 1.4 数据库什么时候会出现事务

增删改的语句会自动开启事务，当然是一条SQL一个事务。注意每个事务都是有编号的，这个编号是一个整数，有递增的特性。

如果要把多条SQL 放在一个事务里面，就要手动开启事务。手动开启事务有两种方式:一种是用begin; 一种是用start transaction。

结束也有两种方式:第一种是回滚事务roll back，事务结束。第二种就是提交一个事务，commit ，事务结束。

如果我们把autocommit 设置成false/off，那么数据库的事务就需要我们手动地结束，用rolback 或者commit。如果客户端断开连接，事务也会结束。

## 1.5 事务并发会带來什么问题?

- 脏读
![](../youdaonote-images/Pasted%20image%2020230709003300.png)

- 不可重复读
![](../youdaonote-images/Pasted%20image%2020230709003343.png)

- 幻读

![](../youdaonote-images/Pasted%20image%2020230709003848.png)

> 事务并发的三大问题其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。

## 1.6 SQL92标准

- Read Uncommitted(RU未提交读) - 未解决任何并发问题 - 事务未提交的数据对其他事务也是可见的，会出现脏读
- Read Committed(RC已提交读) - 解决脏读问题 - 一个事务开始之后，只能看到已提交的事务所做的修改，会出现不可重复读
- Repeatable Read(RR可重复读) - 解决不可重复读问题 - 在同一个事务中多次读取同样的数据结果是一样的，这种隔离级别未解决幻读的问题
- Serializable(串行化) - 解决所有问题 - 最高的隔离级别，通过强制事务的串行执行


## 1.7 MySQL InnoDB对隔离级别的支持

![](../youdaonote-images/Pasted%20image%2020230709004623.png)

## 1.8 两大实现方案

解決读一致性的问题，保证—个事务中前后两次读取数据结果一致，实现事务隔离，应该怎么做?

### 1.8.1 LBCC

既然要保证前后两次读取数据一致，那么锁定我要操作的数据，不允许其他的事务修改就行了。这种方案我们叫做基于锁的并发控制Lock Based Concurrency Control (LBCC)

如果仅仅是基于锁来实现事务隔离，一个事务读取的时候不允许其他时候修改，那就意味着不支持并发的读写操作，而我们的大多数应用都是读多写少的，这样会极大地影响操作数据的效率。

### 1.8.2 MVCC

要让一个事务前后两次读取的数据保持一致，那么我们可以在修改数据的之前给它建立一个备份或者叫快照，后面再来读取这个快照就行了。这种方案我们叫做多版本的并发控制Multi Version Concurrency Control(MVCC)

- MVCC的原则：
	- 一个事务能看到的数据版本：
		1. 第一次查询之前已经提交的事务的修改
		2. 本事务的修改
	- 一个事务不能看见的数据版本：
		1. 在本事务第一次查询之后创建的事务（事务ID比我的事务ID大）
		2. 活跃的（未提交的）事务的修改

不管别的事务做任何增删改查的操作，它只能看到第一次查询时看到的数据版本。

