## 声明一份配置清单

在开始部署前，我们先要声明一份 `配置清单` ，清单的文件格式为 `YAML` 文件格式。在 Kubernetes 中，应用部署完全可以通过 `YAML` 配置清单来进行部署。

新建一个文件夹，名称叫 `deployment`，并在文件夹内创建一份 `yaml` 文件，名称为 `v1`：

```shell
mkdir deployment && cd deployment
vim v1.yaml
```

接着在配置文件中，写入以下内容：

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: front-v1
spec:
  selector:
    matchLabels:
      app: nginx-v1
  replicas: 3
  template:
    metadata:
      labels:
        app: nginx-v1
    spec:
      containers:
      - name: nginx
        image: registry.cn-hangzhou.aliyuncs.com/janlay/k8s_test:v1
        ports:
        - containerPort: 80
```

我们关注下 YAML 文件中的 kind 字段。这是在声明 Kubernetes 的资源类型。在这里，我们的 `kind` 值为 `deployment`。那 `deployment` 又是什么呢？

---

### 什么是 Deployment

如果你将 `k8s` 看作是一个大型机场，那么 `deployment` 刚好就是机场内的**停机坪**。

根据飞机的种类进行划分停机坪，不同的停机坪都停着不同类型的飞机。只不过，`deployment` 要比停机坪还要灵活，随时可以根据剩余的空地大小（服务器剩余资源）和塔台的指令，增大/变小停机坪的空间。**这个“增大变小停机坪空间的动作”，在k8s中就是 `deployment` 对它下面所属容器数量的扩容/缩小的操作。**

![](../youdaonote-images/Pasted%20image%2020230419231205.png)

那么这也就代表，**`deployment`是无状态的，也就不会去负责停机坪中每架飞机之间的通信和组织关系**。只需要根据塔台的指令，维护好飞机的更新和进出指令即可。**这个根据指令维护飞机更新和进出的行为，在k8s中就是 `deployment` 对他下面的容器版本更新升级，暂停和恢复更新升级的动作。**

在这里的**容器**，并不等于 Docker 中的容器。它在K8S中被称为 `Pod` 。那么 `Pod` 是什么 ?

---

### 什么是 Pod

Pod 是 K8S 中最小的可调度单元（可操作/可部署单元），它里面可以包含1个或者多个 Docker 容器。在 Pod 内的所有 Docker 容器，都会共享同一个网络、存储卷、端口映射规则。一个 Pod 拥有一个 IP。

但这个 IP 会随着Pod的重启，创建，删除等跟着改变，所以不固定且不完全可靠。这也就是 Pod 的 IP 漂移问题。这个问题我们可以使用下面的 Service 去自动映射

![](../youdaonote-images/Pasted%20image%2020230419231253.png)

我们经常会把 Pod 和 Docker 搞混，这两者的关系就像是豌豆和豌豆荚，Pod 是一个容器组，里面有很多容器，容器组内共享资源。

---

### 分析配置文件构成

那么相信大家对 `deployment` 有大体的概念了。当然，`kind` 字段不只可以声明 `deploymnt` ，还可以声明其他的资源类型。重要的我们在后面的章节中都会写到。

了解了 `deployment` 是啥后，我们来看看配置清单中的字段都代表的是啥。我们将配置分成三段去进行阅读：

最上面的第一段声明了当前资源配置的 API 版本，资源类型和资源名称：

-   API 配置版本： `apps/v1`
-   资源类型：`deployment`
-   资源名称：`deplyment` 的名称叫 `front-v1`

其中，API 配置版本会随着 K8S 版本迭代和资源类型不同有变化。具体可以看下面这个链接：

> 该怎么选择 apiVersion 的值: [matthewpalmer.net/kubernetes-…](https://link.juejin.cn/?target=https%3A%2F%2Fmatthewpalmer.net%2Fkubernetes-app-developer%2Farticles%2Fkubernetes-apiversion-definition-guide.html "https://matthewpalmer.net/kubernetes-app-developer/articles/kubernetes-apiversion-definition-guide.html")


根据规则匹配相应的 `Pod` 进行控制和管理。这里使用 `matchLabels` 字段匹配 `Pod` 的 `label` 值。

-   replicas：要创建的 `Pod` 最大数量。数字类型
-   labels.app：Pod 组的名称
-   spec：组内创建的 Pod 信息
    -   name：Pod 名称
    -   image：以什么镜像创建 Pod。这里是 Docker 镜像地址
    -   ports.containerPort：Pod 内容器映射的端口

## **启动第一个应用**

好了，在我们了解完一份简单的 `deployment` 的配置清单后，我们就可以使用该清单创建我们的第一个应用。

在k8s中，我们使用 `kubectl apply` 来执行一份k8s的配置：

```shell
kubectl apply -f ./v1.yaml
```

其中，`kubectl apply` 代表准备对资源进行配置。 `-f` 等于 `--filename`，后面可以跟随多个配置文件。例如：

```shell
kubectl apply -f ./v1.yaml ./v1-service.yaml ./v1-ingress.yaml
```

当提示下面文字时，代表配置文件执行成功：

![](../youdaonote-images/Pasted%20image%2020230419231607.png)

