## 整数溢出

下面这个 _C_ 程序 ( _test.c_ ) 运行后输出什么？是 _1000000000000_ (一万亿) 吗？

```c
#include <stdio.h>

int main(int argc, char *argv[])
{
    int value = 1000000;
    printf("%d\n", value * value);

    return 0;
}
```

可能有不少人觉得这没啥好问的，一百万乘以一百万不就是一万亿吗？但现实却不是如此。

在计算机中，由于变量类型存储空间固定，它能表示的数值范围也是有限的。以 _int_ 为例，该类型长度为 _32_ 位，能表示的整数范围为 _-2147483648_ 至 _2147483647_ 。一万亿显然超出该范围，换句话讲程序发生了 **整数溢出** 。因此，运行 _test.c_ ，程序这样输出也就不奇怪了：

```c
$ gcc -o test test.c
$ ./test
-727379968
```

不仅是 _C_ 语言，很多编程语言都存在整数溢出的问题，数据库中的整数类型也是。由于整数溢出现象的存在，程序员需要结合业务场景，谨慎选择数据类型。一旦选择不慎或者代码考虑不周，便会导致严重 _BUG_ 。

## int 对象的行为

与其他语言相比， _Python_ 中的整数永远不会有溢出的现象。一百万乘以一百万， _Python_ 可以轻易算出来：

```c
>>> 1000000 * 1000000
1000000000000
```

_Python_ 甚至可以计算十的一百次方，这在其他语言是不可想象的。

计算结果如此庞大，就算用 _64_ 位整数，也难以表示。但 _Python_ 中的整数对象却可以轻松应付，完全不需要任何特殊处理。

在源码中，我们将领略到 _C_ 语言 **实现大整数的艺术** 。

## int 对象的设计

_int_ 对象在 _Include/longobject.h_ 头文件中定义：

```c
typedef struct _longobject PyLongObject; /* Revealed in longintrepr.h */
```

我们顺着注释找到了 _Include/longintrepr.h_ ，实现 _int_ 对象的结构体真正藏身之处：

```c
struct _longobject {
    PyObject_VAR_HEAD
    digit ob_digit[1];
};
```

这个结构我们并不陌生，说明 _int_ 对象是一个变长对象。除了变长对象都具有的公共头部，还有一个 _digit_ 数组，整数值应该就存储在这个数组里面。 _digit_ 又是什么呢？同样在 _Include/longintrepr.h_ 头文件，我们找到它的定义：

```c
#if PYLONG_BITS_IN_DIGIT == 30
typedef uint32_t digit;
// ...
#elif PYLONG_BITS_IN_DIGIT == 15
typedef unsigned short digit;
// ...
#endif
```

看上去 _digit_ 就是一个 _C_ 语言整数，至此我们知晓 _int_ 对象是通过整数数组来实现大整数的。一个 _C_ 整数类型不够就两个嘛，两个不够那就 _n_ 个！至于整数数组用什么整数类型来实现， _Python_ 提供了两个版本，一个是 _32_ 位的 _uint32_t_ ，一个是 _16_ 位的 _unsigned short_ ，编译 _Python_ 解析器时可以通过宏定义指定选用的版本。

_Python_ 作者为什么要这样设计呢？这主要是出于内存方面的考量：对于范围不大的整数，用 _16_ 位整数表示即可，用 _32_ 位就有点浪费。本人却觉得由于整数对象公共头部已经占了 _24_ 字节，省这 _2_ 个字节其实意义不大。

![](../../youdaonote-images/Pasted%20image%2020221206225407.png)

由此可见，选用 _16_ 位整数数组时， _int_ 对象内存增长的粒度更小，有些情况下可以节省 _2_ 个字节。但是这 _2_ 字节相比 _24_ 字节的变长对象公共头部显得微不足道，因此 _Python_ 默认选用 _32_ 位整数数组也就不奇怪了。

![](../../youdaonote-images/Pasted%20image%2020221206225459.png)

如上图，对于比较大的整数， _Python_ 将其拆成若干部分，保存在 _ob_digit_ 数组中。然而我们注意到在结构体定义中， _ob_digit_ 数组长度却固定为 _1_ ，这是为什么呢？由于 _C_ 语言中数组长度不是类型信息，我们可以根据实际需要为 _ob_digit_ 数组分配足够的内存，并将其当成长度为 _n_ 的数组操作。这也是 _C_ 语言中一个常用的编程技巧。

## 大整数布局

整数分为 **正数** 、 **负数** 和 **零** ， _Python_ 规定不同整数在 _int_ 对象中的存储方式，要点可以总结为 _3_ 条：

-   整数 **绝对值** 根据实际情况分为若干部分，保存于 _ob_digit_ 数组中；
-   _ob_digit_ **数组长度** 保存于 _ob_size_ 字段，对于 **负整数** 的情况，_ob_size_ 为负；
-   整数 **零** 以 _ob_size_ 等于 _0_ 来表示，_ob_digit_ 数组为空；

接下来，我们以 _5_ 个典型的例子详细介绍这几条规则：

![](../../youdaonote-images/Pasted%20image%2020221206230210.png)

