## 一切皆对象

在 _Python_ 世界， **基本类型也是对象** ，与通常意义的“对象”形成一个有机统一。 换句话讲， _Python_ 不再区别对待基本类型和对象，所有基本类型内部均由对象实现。 一个整数是一个对象，一个字符串也是一个对象。

 _Python_ 中的 **类型也是一种对象** ，称为 **类型对象** 。 整数类型是一个对象，字符串类型是一个对象，程序中通过 _class_ 关键字定义的类也是一个对象。

通过整数类型 **实例化** 可以得到一个整数对象，称为 **实例对象** ：

```python
>>> int('1024')
1024
```

![](../../youdaonote-images/Pasted%20image%2020221205163448.png)

## 类型、对象体系

_a_ 是一个整数对象( **实例对象** )，其类型是整数类型( **类型对象** )：
```python
>>> a = 1
>>> type(a)
<class 'int'>
>>> isinstance(a, int)
True

>>> type(int)
<class 'type'>
```

可以看到，整数类型的类型还是一种类型，即 **类型的类型** 。 只是这个类型比较特殊，它的实例对象还是类型对象。

_Python_ 中还有一个特殊类型 _object_ ，所有其他类型均继承于 _object_ ，换句话讲 _object_ 是所有类型的基类：

```python
>>> issubclass(int, object)
True
```

![](../../youdaonote-images/Pasted%20image%2020221205163824.png)

![](../../youdaonote-images/Pasted%20image%2020221205163936.png)

现在不可避免需要讨论 _type_ 以及 _object_ 这两个特殊的类型。

理论上， _object_ 是所有类型的 **基类** ，本质上是一种类型，因此其类型必然是 _type_ 。 而 _type_ 是所有类型的类型，本质上也是一种类型，因此其类型必须是它自己！

```python
>>> type(object)
<class 'type'>
>>> type(object) is type
True

>>> type(type)
<class 'type'>
>>> type(type) is type
True
```

另外，由于 _object_ 是所有类型的 **基类** ，理论上也是 _type_ 的基类( ___base___ 属性)：

```python
>>> issubclass(type, object)
True
>>> type.__base__
<class 'object'>
```

但是 _object_ 自身便不能有基类了。为什么呢？ 对于存在继承关系的类，成员属性和成员方法查找需要回溯继承链，不断查找基类。 因此，继承链必须有一个终点，不然就死循环了。

![](../../youdaonote-images/Pasted%20image%2020221205164114.png)

## 变量只是名字

在 _Python_ 中，一切皆对象，整数也是如此， **变量只是一个与对象关联的名字** ：

![](../../youdaonote-images/Pasted%20image%2020221205164435.png)

而变量赋值，只是将当前对象与另一个名字进行关联，背后的对象是同一个：

![](../../youdaonote-images/Pasted%20image%2020221205164442.png)

因此，在 _Python_ 内部，变量只是一个名字，保存指向实际对象的指针，进而与其绑定。 变量赋值只拷贝指针，并不拷贝指针背后的对象。在C语言中是如下的：

![](../../youdaonote-images/Pasted%20image%2020221205164527.png)

## 可变对象 与 不可变对象

**可变对象** 在对象创建后，其值可以进行修改； 而 **不可变对象** 在对象创建后的整个生命周期，其值都不可修改。

在 _Python_ 中，整数类型是不可变类型， 整数对象是不可变对象。 修改整数对象时， _Python_ 将以新数值创建一个新对象，变量名与新对象进行绑定； 旧对象如无其他引用，将被释放。

![](../../youdaonote-images/Pasted%20image%2020221205164646.png)

> 每次修改整数对象都要创建新对象、回收旧对象，效率不是很低吗？ 确实是。 后续章节将从源码角度来解答： _Python_ 如何通过 **小整数池** 等手段进行优化。

可变对象是指创建后可以修改的对象，典型的例子是 **列表** ( _list_ )：
```python
>>> l = [1, 2]
>>> l
[1, 2]
>>> id(l)
4385900424

>>> l.append(3)
>>> l
[1, 2, 3]
>>> id(l)
4385900424
```

实际上，列表对象内部维护了一个 **动态数组** ，存储元素对象的指针：

![](../../youdaonote-images/Pasted%20image%2020221205164745.png)

