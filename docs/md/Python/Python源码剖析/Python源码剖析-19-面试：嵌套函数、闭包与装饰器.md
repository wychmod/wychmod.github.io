_Python_ 函数可以嵌套定义，我们先考察一个典型的例子：

```python
def adder(n):
    def handler(x):
        return n+x
    return handler
```

_adder_ 函数负责创建处理函数 _handler_ ，处理函数计算参数 x 与固定值 _n_ 的和。因此，如果我们需要一个为参数加上 _1_ 的函数，调用 _adder(1)_ 即可轻松得到：

```python
>>> add1 = adder(1)
>>> add1(10)
11
>>> add1(15)
16
```

同样，如果我们需要一个将参数加上 _5_ 的函数，调用 _adder(5)_ 即可：

```python
>>> add5 = adder(5)
>>> add5(10)
15
>>> add5(15)
20
```

很显然，对于 _add1_ 来说，_n_ 的值是 _1_ ；对于 _add5_ 来说，_n_ 的值是 _5_ ；两者保存独立，互不干扰。

理论上，当函数 _adder_ 返回，局部变量 _n_ 应该就被回收了，为什么 _handler_ 函数还能访问到它呢？

另外，像 _adder_ 函数和 _handler_ 函数这种嵌套写法，到底有什么作用？适用于什么开发场景？有什么需要特别注意的地方吗？

为了解答这诸多疑惑，我们需要深入学习 **嵌套函数** 与 **闭包** 变量的来龙去脉。

## 嵌套函数

像 _adder_ 函数和 _handler_ 这样，在一个函数的函数体内定义另一个函数，就构成了 **嵌套函数** 。我们在 **虚拟机** 部分讲解 **作用域** 时，已对嵌套函数有所了解。你还记得嵌套函数与作用域之间密切的联系吗？

根据我们在虚拟机部分学到的知识，_adder-handler_ 这段简单的代码却包含着 _3_ 个不同的作用域：

![](../../youdaonote-images/Pasted%20image%2020221214182731.png)
作用域是一个静态概念，由 _Python_ 代码语法决定，与编译后产生的 **代码对象** 一一对应。作用域规定了能够被某个代码块访问的变量有哪些，但对变量具体的值则一概不关心。

一旦 _Python_ 程序开始运行，虚拟机需要为作用域中的变量分配一定的存储空间，这就是 **名字空间** 。名字空间依照作用域规则实现，它决定了某个变量在运行时的取值，可以看做是作用域在运行时的动态表现方式。

当 _adder_ 函数执行时，作用域 _A_ 在虚拟机中表现为 **全局** 名字空间，作用域 _B_ 表现为 **局部** 名字空间：

![](../../youdaonote-images/Pasted%20image%2020221214201344.png)

全局与局部这两个名字空间我们已经非常熟悉了，那么 **闭包** 名字空间又该如何理解呢？

## 闭包

**闭包** ( _closure_ ) 是 **词法闭包** ( _Lexical Closure_ ) 的简称，是指引用了自由变量的函数。这些被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。

以 _adder(10)_ 为例，它是一个 _handler_ 函数对象，闭包变量 _n_ 值总是 _10_ 。那么，内层函数是如何访问闭包作用域的呢？我们对函数代码对象进行反汇编，从中可以看出端倪：

```python
>>> add10 = adder(10)
>>> add10
<function adder.<locals>.handler at 0x10dc2b6a8>
>>> add10.__code__
<code object handler at 0x10dbe5150, file "<stdin>", line 2>
>>> dis.dis(add10.__code__)
  3           0 LOAD_DEREF               0 (n)
              2 LOAD_FAST                0 (x)
              4 BINARY_ADD
              6 RETURN_VALUE
```

我们发现一条全新的字节码 _LOAD_DEREF_ ，正是它执行了闭包变量查找工作！_LOAD_FAST_ 指令则负责局部变量查找，而局部名字空间我们已经有所了解，它藏身于栈帧对象中。

那么，闭包名字空间又藏在哪呢？

顺着虚拟机处理 _LOAD_DEREF_ 字节码的代码，不难找到答案。与该字节码处理相关的源码位于 _Python/ceval.c_ 文件，有兴趣的同学可以深入看一下。

因篇幅所限，这里直接给出答案：当闭包函数 _handler_ 执行时，闭包变量藏身于 _PyFrameObject_ 中。

还记得吗？每次函数调用虚拟机都会创建一个 _PyFrameObject_ 对象，用于保存函数调用上下文。全局名字空间与局部名字空间都藏身其中，闭包名字空间也不例外。

前面章节提过，_PyFrameObject_ 结构体最后部分是不固定的，依次存放着静态局部名字空间、闭包名字空间以及临时栈。以 _add10(1)_ 为例，函数运行时 _PyFrameObject_ 状态如下如下：