_Python_ 函数可以嵌套定义，我们先考察一个典型的例子：

```python
def adder(n):
    def handler(x):
        return n+x
    return handler
```

_adder_ 函数负责创建处理函数 _handler_ ，处理函数计算参数 x 与固定值 _n_ 的和。因此，如果我们需要一个为参数加上 _1_ 的函数，调用 _adder(1)_ 即可轻松得到：

```python
>>> add1 = adder(1)
>>> add1(10)
11
>>> add1(15)
16
```

同样，如果我们需要一个将参数加上 _5_ 的函数，调用 _adder(5)_ 即可：

```python
>>> add5 = adder(5)
>>> add5(10)
15
>>> add5(15)
20
```

很显然，对于 _add1_ 来说，_n_ 的值是 _1_ ；对于 _add5_ 来说，_n_ 的值是 _5_ ；两者保存独立，互不干扰。

理论上，当函数 _adder_ 返回，局部变量 _n_ 应该就被回收了，为什么 _handler_ 函数还能访问到它呢？

另外，像 _adder_ 函数和 _handler_ 函数这种嵌套写法，到底有什么作用？适用于什么开发场景？有什么需要特别注意的地方吗？

为了解答这诸多疑惑，我们需要深入学习 **嵌套函数** 与 **闭包** 变量的来龙去脉。

## 嵌套函数

像 _adder_ 函数和 _handler_ 这样，在一个函数的函数体内定义另一个函数，就构成了 **嵌套函数** 。我们在 **虚拟机** 部分讲解 **作用域** 时，已对嵌套函数有所了解。你还记得嵌套函数与作用域之间密切的联系吗？

根据我们在虚拟机部分学到的知识，_adder-handler_ 这段简单的代码却包含着 _3_ 个不同的作用域：

![](../../youdaonote-images/Pasted%20image%2020221214182731.png)
作用域是一个静态概念，由 _Python_ 代码语法决定，与编译后产生的 **代码对象** 一一对应。作用域规定了能够被某个代码块访问的变量有哪些，但对变量具体的值则一概不关心。

一旦 _Python_ 程序开始运行，虚拟机需要为作用域中的变量分配一定的存储空间，这就是 **名字空间** 。名字空间依照作用域规则实现，它决定了某个变量在运行时的取值，可以看做是作用域在运行时的动态表现方式。

当 _adder_ 函数执行时，作用域 _A_ 在虚拟机中表现为 **全局** 名字空间，作用域 _B_ 表现为 **局部** 名字空间：