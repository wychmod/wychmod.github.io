# list操作解析
## 基本用法

我们先来回顾一下 _list_ 对象的基本操作：

```python
# 新建一个列表
>>> l = [1, 2, 3]
>>> l
[1, 2, 3]

# 向尾部追加元素，列表对象视情况自动扩容
>>> l.append(4)
>>> l
[1, 2, 3, 4]

# 从尾部弹出元素，列表对象视情况自动缩容
>>> l.pop()
4
>>> l
[1, 2, 3]

# 向头部插入元素，该操作需要挪动后面的元素，谨慎使用！
>>> l.insert(0, 4)
>>> l
[4, 1, 2, 3]

# 从头部弹出元素，该操作需要挪动后面的元素，谨慎使用！
>>> l.pop(0)
4
>>> l
[1, 2, 3]

# 查找元素第一次出现位置的下标
>>> l.index(2)
1

# 用一个可迭代对象扩展列表——元素逐一追加到尾部
>>> l.extend([1, 2])
>>> l
[1, 2, 3, 1, 2]

# 计算元素出现的个数
>>> l.count(1)
2
>>> l.count(3)
1

# 将列表反转
>>> l.reverse()
>>> l
[2, 1, 3, 2, 1]

# 将列表清空
>>> l.clear()
>>> l
[]
```

一个合格的 _Python_ 开发工程师，除了必须熟练掌握 _list_ 对象的基本操作，还需要对每个操作的 **实现原理** 及对应的 **时间复杂度** 、 **空间复杂度** 有准确的认识。列表操作总体比较简单，但有个操作特别容易被误用：

-   _insert_ 方法向头部追加元素时需要挪动整个列表，时间复杂度是 O(n)O(n) ，性能极差，需谨慎使用；
-   _append_ 方法向尾部追加元素时，无需挪动任何元素，时间复杂度 O(1)O(1) ；
-   _pop_ 方法从头部弹出元素时也需要挪动整个列表，时间复杂度是 O(n)O(n) ，同样需谨慎使用；
-   _pop_ 方法从尾部弹出元素时，无需挪动任何元素，时间复杂度是 O(1)O(1)

由此可见，对列表头部和尾部进行操作，性能有天壤之别。后续我们将一起探索 _list_ 对象内部结构，从中寻找造成这种现象的原因。此外， _list_ 对象还可根据元素个数 **自动扩缩容** 。

## 内部结构

_list_ 对象在 _Python_ 内部，由 _PyListObject_ 结构体表示，定义于头文件 _Include/listobject.h_ 中：

```c
typedef struct {
    PyObject_VAR_HEAD
    /* Vector of pointers to list elements.  list[0] is ob_item[0], etc. */
    PyObject **ob_item;

    /* ob_item contains space for 'allocated' elements.  The number
     * currently in use is ob_size.
     * Invariants:
     *     0 <= ob_size <= allocated
     *     len(list) == ob_size
     *     ob_item == NULL implies ob_size == allocated == 0
     * list.sort() temporarily sets allocated to -1 to detect mutations.
     *
     * Items must normally not be NULL, except during construction when
     * the list is not yet visible outside the function that builds it.
     */
    Py_ssize_t allocated;
} PyListObject;
```

毫无疑问， _list_ 对象是一种 **变长对象** ，因此包含变长对象公共头部。除了公共头部， _list_ 内部维护了一个动态数组，而数组则依次保存元素对象的指针：

-   _**ob_item**_ ，指向动态数组的指针，动态数组保存元素对象的指针；
-   _**allocated**_ ，动态数组长度，即列表 **容量** ；
-   _**ob_size**_ ，动态数组当前保存元素个数，即列表 **长度** 。

![](../../youdaonote-images/Pasted%20image%2020221210120532.png)

## 尾部操作

在列表对象尾部增删元素，可快速完成，无须挪动其他元素。

假设列表元素 _l_ 内部数组长度为 _5_ ，以及保存 _3_ 个元素，分别是： _1_ 、 _2_ 、 _3_ 。当我们调用 _append_ 方法向尾部追加元素时，由于内部数组还有未用满，只需将新元素保存于数组下一可用位置并更新 _ob_size_ 字段：

![](../../youdaonote-images/Pasted%20image%2020221210120541.png)

因此，大多数情况下， _append_ 方法性能都足够好，时间复杂度是 O(1)。

## 动态扩容

如果 _list_ 对象内部数组已用满，再添加元素时则需要进行扩容。 _append_ 等方法在操作时都会对内部数组进行检查，如需扩容则调用 _list_resize_ 函数。在 _list_resize_ 函数， _Python_ 重新分配一个长度更大的数组并替换旧数组。为避免频繁扩容， _Python_ 每次都会为内部数组预留一定的裕量。

假设列表元素 _l_ 保存 _3_ 个元素，内部数组长度为 _3_ ，已满。当我们调用 _append_ 方法向列表尾部追加元素时，需要对内部数组进行扩容。扩容步骤如下：

![](../../youdaonote-images/Pasted%20image%2020221210121136.png)

1.  分配一个更大的数组，假设长度为 _6_ ，预留一定裕量避免频繁扩容；
2.  将列表元素从旧数组逐一转移到新数组；
3.  以新数组替换旧数组，并更新 _allocated_ 字段；
4.  回收旧数组。

由于内部数组扩容时，需要将列表元素从旧数组拷贝到新数组，时间复杂度为 O(n) ，开销较大，需要尽量避免。为此， _Python_ 在为内部数组扩容时，会预留一定裕量，一般是 1/81/8 左右。假设为长度为 _1000_ 的列表对象扩容， _Python_ 会预留大约 _125_ 个空闲位置，分配一个长度 _1125_ 的新数组。

由于扩容操作的存在， _append_ 方法最坏情况下时间复杂度为 O(n)。由于扩容操作不会频繁发生，将扩容操作时的元素拷贝开销平摊到多个 _append_ 操作中，平均时间复杂度还是 O(1)。

## 头部操作

与尾部相比，由于在列表头部增删元素需要挪动其他列表元素，性能有天地之别。

假设列表元素 _l_ 内部数组长度为 _5_ ，以及保存 _3_ 个元素，分别是： _1_ 、 _2_ 、 _3_ 。当我们调用 _insert_ 方法向头部插入元素时，需要先将当前所有元素往后挪一位，以便为新元素腾出一个空闲位置：

![](../../youdaonote-images/Pasted%20image%2020221210125718.png)

然后， _insert_ 方法将新元素存入挪出来的空闲位置，更新新 _ob_size_ 字段，便完成了插入操作：

![](../../youdaonote-images/Pasted%20image%2020221210125728.png)

因此， _insert_ 在头部插入元素的时间复杂度是 O(n)O(n) ，必须谨慎使用，尽量避免。调用 _pop_ 方法从头部弹出元素，性能也是很差，时间复杂度同样是 O(n)O(n)。笔者见过有人将 _list_ 对象当成一个 **队列** 来用，真想把他抓起来打一顿：

```python
q = []

# enqueue
q.append(job)

# dequeue
job = q.pop(0)
```

这个队列实现，出队操作需要将整个队列挪动一遍，性能很差。如果队列规模很大，这将成为拖垮程序的关键因素。如果队列规模很小，这种写法虽说问题不大，但也不建议——你最好不要在代码中埋一颗不知什么时候会爆炸的雷。

如果你需要频繁操作列表头部，可以考虑使用标准库里的 _deque_ ，这是一种 **双端队列** 结构。 _deque_ 头部和尾部操作性能都很优秀，时间复杂度都是 O(1)O(1) 。如果你需要一个 **先进先出** ( _FIFO_ )队列，可以这么写：

```python
from collections import deque

q = deque()

# enqueue
q.append(job)

# dequeue
q.popleft()
```

## 浅拷贝

调用 _list_ 对象 _copy_ 方法，可将列表拷贝一份，生成一个全新的列表：

```python
# 创建一个列表
>>> l = [1, [2], 'three']
>>> l
[1, [2], 'three']

# 拷贝形成一个新列表
>>> l2 = l.copy()
>>> l2
[1, [2], 'three']
>>> id(l), id(l2)
(4417331976, 4420505736)

# 修改新列表不影响旧列表
>>> l2[0] = 'one'
>>> l2
['one', [2], 'three']
>>> l
[1, [2], 'three']

# 但是修改新列表中的可变元素，旧列表也跟着变！
>>> l2[1][0] = 'two'
>>> l2
['one', ['two'], 'three']
>>> l
[1, ['two'], 'three']
```

由于 _copy_ 方法只是对列表对象进行 **浅拷贝** ，对新列表可变元素的修改对旧列表可见！

如何理解浅拷贝呢？我们知道，列表对象内部数组保存元素对象的 **指针** ； _copy_ 方法复制内部数组时，拷贝的也是元素对象的指针，而不是将元素对象拷贝一遍。因此，新列表对象与旧列表保存的都是同一组对象：

![](../../youdaonote-images/Pasted%20image%2020221210130017.png)

由此可见，_l_ 和 _l2_ 内嵌的列表对象其实是同一个，一旦对其进行修改，对 _l_ 和 _l2_ 都可见。

_copy_ 方法实现的浅拷贝行为，可能不是你想要的。这时，可以通过 _copy_ 模块里的 _deepcopy_ 函数进行 **深拷贝** ：

```python
# 创建一个列表
>>> l = [1, [2], 'three']
>>> l
[1, [2], 'three']

# 对列表进行深拷贝
>>> from copy import deepcopy
>>> l2 = deepcopy(l)
>>> l2
[1, [2], 'three']

# 修改新列表不会影响旧列表
>>> l2[1][0] = 'two'
>>> l2
[1, ['two'], 'three']
>>> l
[1, [2], 'three']
```

_deepcopy_ 函数将递归复制所有容器对象，确保新旧列表不会包含同一个容器对象。这样一来，代码第 _13_ 行处的修改，便对原列表不可见了。深拷贝的行为跟浅拷贝恰好相反。

**浅拷贝** 和 **深拷贝** 是 _Python_ 面试中频繁考察的概念，必须完全掌握。

## 小结

本节我们一起回顾了 _list_ 对象的典型用法并在此基础上研究其内部结构。 _list_ 对象是一种 **变长对象** ，内部结构除了变长对象 **公共头部** 外，维护着一个 **动态数组** ，用于保存元素对象指针。其中，关键字段包括：

-   _ob_item_ ， **动态数组** 指针，数组保存元素对象指针；
-   _allocated_ ，动态数组长度，即列表 **容量** ；
-   _ob_size_ ，动态数组已保存元素个数，即列表 **长度** 。

_Python_ 内部负责管理 _list_ 对象的容量，在必要时 **自动扩缩容** ，极大降低开发人员的负担。

列表头部操作与尾部操作的性能差距非常大，而 _collections.deque_ 作为替代品可解决列表头部操作的性能问题。列表 _copy_ 方法只实现了 **浅拷贝** ，想要 **深拷贝** 只能借助 _copy.deepcopy_ 函数。

# list源码解析