## **请问** **Python** **程序是怎么运行的？是编译成机器码后在执行的吗？试着与 _**C、C++ 、Java、Shell**_ 等常见语言比较说明**。

执行 _Python_ 程序的 _python_ 命令也被称为 _Python_ 解释器，但它其实包含一个 **编译器** 和一个 **虚拟机** 。

当我们在命令行敲下 `python xxxx.py` 时，_python_ 命令中的编译器首先登场，将 _Python_ 代码编译成 **代码** 对象。**代码** 对象包含 **字节码** 以及执行字节码所需的 **名字** 以及 **常量** 。

当编译器完成编译动作后，接力棒便传给 **虚拟机** 。**虚拟机** 维护执行上下文，逐行执行 **字节码** 指令。执行上下文中最核心的 **名字空间** ，便是由 **虚拟机** 维护的。

因此，_Python_ 程序的执行原理其实更像 _Java_，可以用两个词来概括—— **虚拟机**和**字节码** 。不同的是，_Java_ 编译器 _javac_ 与 虚拟机 _java_ 是分离的，而 _Python_ 将两者整合成一个 _python_ 命令。此外，_Java_ 程序执行前必须先完整编译，而 _Python_ 则允许程序启动后再编译并加载需要执行的模块。

## **pyc** **文件保存什么东西，有什么作用？**

_Python_ 程序执行时需要先由 **编译器** 编译成 **代码** 对象，然后再交由 **虚拟机** 来执行。不管程序执行多少次，只要源码没有变化，编译后得到的代码对象就肯定是一样的。因此，_Python_ 将代码对象序列化并保存到 _pyc_ 文件中。当程序再次执行时，_Python_ 直接从 _pyc_ 文件中加载代码对象，省去编译环节。当然了，当 _py_ 源码文件改动后，_pyc_ 文件便失效了，这时 _Python_ 必须重新编译 _py_ 文件。

**如何查看** **Python** **程序的字节码？**

_Python_ 标准库中的 _dis_ 模块，可以对**代码**对象以及 **函数** 对象进行反编译，并显示其中的 **字节码**。

例如，对于函数 _add_ ，通过 ___code___ 字段取到它的 **代码** 对象，并调用 _dis_ 进行反编译：

```python
>>> def add(x, y):
...     return x + y
...
>>> dis.dis(add.__code__)
  2           0 LOAD_FAST                0 (x)
              2 LOAD_FAST                1 (y)
              4 BINARY_ADD
              6 RETURN_VALUE
```

当然了，直接将 **函数** 对象传给 _dis_ 也可以：

```python
>>> dis.dis(add)
  2           0 LOAD_FAST                0 (x)
              2 LOAD_FAST                1 (y)
              4 BINARY_ADD
              6 RETURN_VALUE
```

**Python** **中变量交换有两种不同的写法，示例如下。这两种写法有什么区别吗？那种写法更好？**

```python
# 写法一
a, b = b, a

# 写法二
tmp = a
a = b
b = tmp
```

这两种写法都能实现变量交换，表面上看第一种写法更加简洁明了，似乎更优。那么，在优雅的外表下是否隐藏着不为人知的性能缺陷呢？想要找打答案，唯一的途径是研究字节码：

```python
# 写法一
  1           0 LOAD_NAME                0 (b)
              2 LOAD_NAME                1 (a)
              4 ROT_TWO
              6 STORE_NAME               1 (a)
              8 STORE_NAME               0 (b)
```

```python
# 写法二
  1           0 LOAD_NAME                0 (a)
              2 STORE_NAME               1 (tmp)

  2           4 LOAD_NAME                2 (b)
              6 STORE_NAME               0 (a)

  3           8 LOAD_NAME                1 (tmp)
             10 STORE_NAME               2 (b)
```

从字节码上看，第一种写法需要的指令条目也更少：先将两个变量依次加载到栈，然后一条 _ROT_TWO_ 指令将栈中的两个变量交换，最后再将变量依次写回去。注意到，变量加载的顺序与 _=_ 右边一致，写回顺序与 _=_ 左边一致。

![](../../youdaonote-images/Pasted%20image%2020221213175338.png)

