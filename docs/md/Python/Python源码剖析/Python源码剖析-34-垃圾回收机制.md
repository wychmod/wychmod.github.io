_Python_ 内部采用 **引用计数法** ，为每个对象维护引用次数，并据此回收不再需要的垃圾对象。由于引用计数法存在重大缺陷，循环引用时有内存泄露风险，因此 _Python_ 还采用 **标记清除法** 来回收存在循环引用的垃圾对象。此外，为了提高垃圾回收( _GC_ )效率，_Python_ 还引入了 **分代回收机制** 。

## 对象跟踪

将程序内部对象跟踪起来，是实现垃圾回收的第一步。那么，是不是程序创建的所有对象都需要跟踪呢？

一个对象是否需要跟踪，取决于它会不会形成循环引用。按照引用特征，_Python_ 对象可以分为两类：

-   **内向型对象** ，例如 _int_ 、_float_ 、 _str_ 等，这类对象不会引用其他对象，因此无法形成循环引用，无须跟踪；
-   **外向型对象** ，例如 _tuple_ 、 _list_ 、 _dict_ 等容器对象，以及函数、类实例等复杂对象，这类对象一般都会引用其他对象，存在形成循环引用的风险，因此是垃圾回收算法关注的重点；

这是一个典型的例子，橘红色外向型对象存在循环引用的可能性，需要跟踪；而绿色内向型对象在引用关系图中只能作为叶子节点存在，无法形成任何环状，因此无需跟踪：